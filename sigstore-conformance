#!/usr/bin/env python3

import argparse
import enum
import logging
import os
import pathlib
from dataclasses import dataclass
from test.functional import basic
from typing import List, Type

import docker


class SigstoreClientChoice(str, enum.Enum):
    """
    The Sigstore client to test.
    """

    All = "all"
    SigstorePython = "sigstore-python"
    Cosign = "cosign"

    def __str__(self) -> str:
        return self.value


class ReleaseTypeChoice(str, enum.Enum):
    """
    The release type for a given client.
    """

    All = "all"
    Stable = "stable"
    Nightly = "nightly"

    def __str__(self) -> str:
        return self.value


FUNCTIONAL_TESTS = [basic]

logger = logging.getLogger(__name__)
logging.basicConfig(
    level=os.environ.get("SIGSTORE_CONFORMANCE_LOGLEVEL", "INFO").upper()
)


def _enum_help(msg: str, e: Type[enum.Enum]) -> str:
    """
    Render a `--help`-style string for the given enumeration.
    """
    return f"{msg} (choices: {', '.join(str(v) for v in e)})"


def _parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="sigstore-conformance",
        description="Conformance testing for Sigstore clients",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    subcommands = parser.add_subparsers(required=True, dest="subcommand")

    # `sigstore-conformance build`
    subcommands.add_parser(
        "build", formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    # `sigstore-conformance test`
    subcommands.add_parser(
        "test", formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument(
        "--client",
        "-c",
        type=SigstoreClientChoice,
        choices=SigstoreClientChoice,
        default=SigstoreClientChoice.All,
        metavar="CLIENT",
        help=_enum_help(
            "the sigstore client to test (tests all clients by default)",
            SigstoreClientChoice,
        ),
    )
    parser.add_argument(
        "--release",
        "-r",
        type=ReleaseTypeChoice,
        choices=ReleaseTypeChoice,
        default=ReleaseTypeChoice.All,
        metavar="RELEASE",
        help=_enum_help(
            "the release type to test (tests all release types by default)",
            ReleaseTypeChoice,
        ),
    )

    return parser


@dataclass(frozen=True)
class ClientRelease:
    client: str
    release: str

    @property
    def tag(self) -> str:
        return f"{self.client}_{self.release}"

    @property
    def dockerfile_path(self) -> str:
        return str(pathlib.Path.cwd() / "conformance" / self.release / self.client)


def _build(client_releases: List[ClientRelease]) -> None:
    docker_client = docker.from_env()

    for client in client_releases:
        logger.info(f"Building image: {client.tag}")

        # TODO(alex): Cache images
        docker_client.images.build(path=client.dockerfile_path, tag=client.tag)


def _test(client_releases: List[ClientRelease]) -> None:
    docker_client = docker.from_env()

    for client in client_releases:
        logger.info(f"Running tests: {client.tag}")

        for test in FUNCTIONAL_TESTS:
            test(docker_client, client.tag)


def _build_matrix(
    client: SigstoreClientChoice, release: ReleaseTypeChoice
) -> List[ClientRelease]:
    clients = []
    if client == SigstoreClientChoice.All:
        for v in SigstoreClientChoice:
            if v == SigstoreClientChoice.All:
                continue
            clients.append(str(v))
    else:
        clients.append(str(client))

    releases = []
    if release == ReleaseTypeChoice.All:
        for v in ReleaseTypeChoice:
            if v == ReleaseTypeChoice.All:
                continue
            releases.append(str(v))
    else:
        releases.append(str(release))

    client_releases = []
    for c in clients:
        for r in releases:
            client_releases.append(ClientRelease(c, r))

    logger.debug(f"Generated client releases: {client_releases}")
    return client_releases


def _main() -> None:
    parser = _parser()
    args = parser.parse_args()

    # Change current working directory to where this file is
    file_path = pathlib.Path(__file__).parent.resolve()
    os.chdir(file_path)

    # Figure out what client/release pairings we need to test
    client_releases = _build_matrix(args.client, args.release)

    if args.subcommand == "build":
        _build(client_releases)
    elif args.subcommand == "test":
        _test(client_releases)
    else:
        parser.error(f"Unknown subcommand: {args.subcommand}")


if __name__ == "__main__":
    _main()
